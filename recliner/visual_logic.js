/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.6.0
 * Mon, 18 Mar 2024 11:30:47 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    /**
     * Get an HTML element by the given id.
     * @param {(string|Array<string>)} id An HTML element id or an array in the
     * format ["CONTAINER"] (app's container HTML element), or in the format
     * ["WINDOW"] (page's window object), or in the format ["DOCUMENT"] (page's
     * document object), or in the format ["BODY"] (document's body element) or in
     * the format ["QUERYSELECTOR"] (CSS selector string).
     * @param {boolean} [isParent=false] Use the parent document/window to search
     * for the element.
     * @returns {?(HTMLElement|Window|Document)} An HTML element, window,
     * document depending on the given "id" parameter or "null" if nothing was
     * found.
     */
    function getElement(id, isParent=false) {
        let elem;
        if (Array.isArray(id) && id[0] === 'CONTAINER') {
            if (appInstance !== null) {
                elem = appInstance.container;
            } else if (typeof _initGlob !== 'undefined') {
                // if we are on the initialization stage, we still can have access
                // to the container element
                const contId = _initGlob.container;
                elem = isParent ? parent.document.getElementById(contId)
                        : document.getElementById(contId);
            }
        } else if (Array.isArray(id) && id[0] === 'WINDOW') {
            elem = isParent ? parent : window;
        } else if (Array.isArray(id) && id[0] === 'DOCUMENT') {
            elem = isParent ? parent.document : document;
        } else if (Array.isArray(id) && id[0] === 'BODY') {
            elem = isParent ? parent.document.body : document.body;
        } else if (Array.isArray(id) && id[0] === 'QUERYSELECTOR') {
            elem = isParent ? parent.document.querySelector(id)
                    : document.querySelector(id);
        } else {
            elem = isParent ? parent.document.getElementById(id)
                    : document.getElementById(id);
        }
        return elem;
    }
    
    /**
     * Get an array of HTML elements or a single HTML element by the given ids/id.
     * @param {Array<string>} ids An array of HTML element ids or an array with its
     * first element being "CONTAINER" (app's container HTML element),
     * "WINDOW" (page's window object), "DOCUMENT" (page's document object),
     * "BODY" (document's body element) or "QUERYSELECTOR" (CSS selector string).
     * @param {boolean} [isParent=false] Use the parent document/window to search
     * for elements.
     * @returns {?(Array<?HTMLElement>|HTMLElement|Window|Document)} An array of
     * HTML elements or a single HTML element, window, document depending on the
     * given "ids" parameter or "null" if nothing was found.
     */
    function getElements(ids, isParent=false) {
        const elems = [];
        if (Array.isArray(ids) && ids[0] !== 'CONTAINER' && ids[0] !== 'WINDOW'
                && ids[0] !== 'DOCUMENT' && ids[0] !== 'BODY'
                && ids[0] !== 'QUERYSELECTOR') {
            for (let i = 0; i < ids.length; i++) {
                elems.push(getElement(ids[i], isParent));
            }
        } else {
            elems.push(getElement(ids, isParent));
        }
        return elems;
    }
        
    /**
     * Check whether the given object is a Data URL string or not.
     * @param {*} obj Object to check.
     * @returns {boolean} Check result.
     */
    function isDataUrl(obj) {
        // NOTE: checking with dataUrlRe is slow
        return (typeof obj === 'string' && obj.indexOf('data:') === 0);
    }
    
    /**
     * A regular expression to parse a Data URL string.
     * @constant
     * @type {RegExp}
     * @default
     */
    const dataUrlRe = /^data:(.+\/.+);base64,(.*)$/;
    
    /**
     * Decode the given base64 string into a Unicode string.
     * @param {string} str Base64 string to decode.
     * @returns {string} Base64 string converted to a Unicode string.
     * @see https://bit.ly/3dvpq60
     */
    function decodeUnicodeStrFromBase64(str) {
        return decodeURIComponent(atob(str).split('').map(c => {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
        }).join(''));
    }
    
    /**
     * Extract data from the given Data URL string.
     * @param {string} str Data URL string to extract from.
     * @returns {string} Extracted data as a Unicode string.
     */
    function extractDataUrlData(str) {
        const matches = str.match(dataUrlRe);
        return decodeUnicodeStrFromBase64(matches[2]);
    }
        
    /**
     * Check whether 2 event listeners are the same or not.
     * NOTE: "capture" is the only option that affects the fact if the listeners are
     * the same or not.
     * @see https://dom.spec.whatwg.org/#ref-for-dom-eventtarget-addeventlistener%E2%91%A2
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener#matching_event_listeners_for_removal
     * @param {EventTarget} target0 Event target the first event listener is
     * registered on.
     * @param {string} type0 Event type of the first even listener.
     * @param {?Function} listener0 Listener object (null, function or an object
     * with a handleEvent() method) of the first event listener.
     * @param {(Object|boolean)} optionsOrUseCapture0 Event listener options (or the
     * useCapture flag) of the first event listener.
     * @param {EventTarget} target1 Event target the second listener is registered
     * on.
     * @param {string} type1 Event type of the second even listener.
     * @param {?Function} listener1 Listener object (null, function or an object
     * with a handleEvent() method) of the second event listener.
     * @param {(Object|boolean)} optionsOrUseCapture1 Event listener options (or the
     * useCapture flag) of the second event listener.
     * @returns {boolean} Check result.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     */
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
    
    /**
     * Add the specified event listener to the specified event target. Also register
     * it in _pGlob.eventListeners for easier removal further. This function doesn't
     * add the exact same listener if it was already added.
     *
     * NOTE: automatic removal of an event listener via options.once and
     * options.signal is not reflected in _pGlob.eventListeners. In such cases
     * one must call unbindListener() manually to keep _pGlob.eventListeners
     * updated and to avoid potential issues with how the code checks if the given
     * listener already exists in _pGlob.eventListeners or not.
     *
     * @param {EventTarget} target Event target.
     * @param {string} type Event type.
     * @param {?Function} listener Listener object (null, function or an object
     * with a handleEvent() method).
     * @param {(Object|boolean)} optionsOrUseCapture Event listener options (or the
     * useCapture flag).
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     */
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    /**
     * Get editable textures from the given material. The material should be an
     * instance of MeshNodeMaterial or MeshStandardMaterial.
     * @param {string} matName Material name.
     * @param {boolean} [collectSameNameMats=false] Whether to collect textures from
     * all materials with the same name or from the first material with that name
     * found on the scene (default behavior).
     * @returns {Array<v3d.Texture>} Array of editable textures for the material.
     */
    function getMaterialEditableTextures(matName, collectSameNameMats=false) {
        let mats = [];
        if (collectSameNameMats) {
            mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        } else {
            const firstMat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
            if (firstMat !== null) {
                mats = [firstMat];
            }
        }
    
        const textures = mats.reduce((texArray, mat) => {
            let matTextures = [];
            switch (mat.type) {
                case 'MeshNodeMaterial':
                    matTextures = Object.values(mat.nodeTextures);
                    break;
    
                case 'MeshStandardMaterial':
                    matTextures = [
                        mat.map, mat.lightMap, mat.aoMap, mat.emissiveMap,
                        mat.bumpMap, mat.normalMap, mat.displacementMap,
                        mat.roughnessMap, mat.metalnessMap, mat.alphaMap, mat.envMap
                    ];
                    break;
    
                default:
                    console.error('getMaterialEditableTextures: Unknown material type '
                            + mat.type);
                    break;
            }
    
            Array.prototype.push.apply(texArray, matTextures);
            return texArray;
        }, []);
    
        return textures.filter(elem => {
            // check Texture type exactly
            return elem && (elem.constructor === v3d.Texture
                    || elem.constructor === v3d.CompressedTexture
                    || elem.constructor === v3d.DataTexture
                    || elem.constructor === v3d.CanvasTexture
                    || elem.constructor === v3d.VideoTexture);
        });
    }
    
    /**
     * Replace the specified texture on the given material with a new one. The
     * material should be an instance of MeshNodeMaterial or MeshStandardMaterial.
     * @param {(v3d.MeshNodeMaterial|v3d.MeshStandardMaterial)} mat Material.
     * @param {v3d.Texture} oldTex Old texture from the material to be replaced.
     * @param {v3d.Texture} newTex New texture to put onto the material.
     */
    function replaceMaterialEditableTexture(mat, oldTex, newTex) {
        switch (mat.type) {
            case 'MeshNodeMaterial':
                for (const name in mat.nodeTextures) {
                    if (mat.nodeTextures[name] === oldTex) {
                        mat.nodeTextures[name] = newTex;
                    }
                }
                break;
    
            case 'MeshStandardMaterial':
                const texNames = ['map', 'lightMap', 'aoMap', 'emissiveMap',
                        'bumpMap', 'normalMap', 'displacementMap', 'roughnessMap',
                        'metalnessMap', 'alphaMap', 'envMap'];
    
                texNames.forEach(name => {
                    if (mat[name] === oldTex) {
                        mat[name] = newTex;
                    }
                });
                break;
    
            default:
                console.error('replaceMaterialEditableTexture: Unsupported material type '
                        + mat.type);
                break;
        }
    
        // inherit some save params
        newTex.encoding = oldTex.encoding;
        newTex.wrapS = oldTex.wrapS;
        newTex.wrapT = oldTex.wrapT;
    }
    
    /**
     * Get the names of the scalar "value" properties for the given material that
     * don't require shader recompilation in order to apply changes after editing.
     * For MeshNodeMaterial those are the names of Value nodes.
     * @param {string} matName Material name.
     * @returns {Array<string>} Editable scalar "value" properties for the material.
     */
    function getMaterialEditableValues(matName) {
        const mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
        if (!mat) {
            return [];
        }
    
        if (mat.isMeshNodeMaterial) {
            return Object.keys(mat.nodeValueMap);
        } else if (mat.isMeshStandardMaterial) {
            return ['metalness', 'roughness', 'bumpScale', 'emissiveIntensity',
                    'envMapIntensity'];
        } else {
            return [];
        }
    }
    
    /**
     * Get the given scene's animation framerate.
     * @param {v3d.Scene} scene Scene.
     * @returns {number} Scene's animation framerate.
     */
    function getSceneAnimFrameRate(scene) {
        if (scene && 'animFrameRate' in scene.userData) {
            return scene.userData.animFrameRate;
        }
        return 24;
    }
    
    /**
     * Get a scene that contains the root of the given action.
     * @param {v3d.AnimationAction} action Animation action.
     * @returns {?v3d.Scene} The scene containing the given action or "null" if no
     * such scene found.
     */
    function getSceneByAction(action) {
        const root = action.getRoot();
        let scene = root.type === 'Scene' ? root : null;
        root.traverseAncestors(ancObj => {
            if (ancObj.type === 'Scene') {
                scene = ancObj;
            }
        });
        return scene;
    }

    return {
        getElement, getElements, isDataUrl, extractDataUrlData,
        bindListener, getMaterialEditableTextures, replaceMaterialEditableTexture, getMaterialEditableValues,
        getSceneAnimFrameRate, getSceneByAction,
    };
};

var PL = {};
// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};


_pGlob.wooProductInfo = {};


PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["check_total_price"] = check_total_price;
this.procedures["number_to_price"] = number_to_price;
this.procedures["pricelist_read"] = pricelist_read;
this.procedures["item_quantity_changing"] = item_quantity_changing;

var input_number, row_number, item_quantity_id, list_id, add_or_sub, total_price, pricelist, total_items_in_basket, recliner_unfolded, shopping_cart, animated_parts, current_item, reclainer_parts;

// getHTMLElemAttribute puzzle
function getHTMLElemAttribute(attr, id, isParent) {
    var elem = PzLib.getElement(id, isParent);
    return elem ? elem[attr]: '';
}

// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// Describe this function...
function check_total_price() {
  total_price = String(getHTMLElemAttribute('innerHTML', 'item_quantity_1', true) * pricelist[0][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_2', true) * pricelist[1][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_3', true) * pricelist[2][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_4', true) * pricelist[3][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_5', true) * pricelist[4][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_6', true) * pricelist[4][2] + getHTMLElemAttribute('innerHTML', 'item_quantity_7', true) * pricelist[4][2]);
  if (number_to_price(total_price) != '$,0.00') {
    setHTMLElemAttribute('innerHTML', number_to_price(total_price), 'total_price', true);
  } else {
    setHTMLElemAttribute('innerHTML', '$0.00', 'total_price', true);
  }
}

// Describe this function...
function number_to_price(input_number) {
  return ['$',input_number.slice(0, input_number.length - 3),',',input_number.slice(input_number.length - 3, input_number.length - 0),'.00'].join('');
}

// Describe this function...
function pricelist_read(row_number) {
  setHTMLElemAttribute('innerHTML', pricelist[row_number][0], 'item_name', true);
  setHTMLElemAttribute('innerHTML', 'ITEM# - ' + String(pricelist[row_number][1]), 'item_number', true);
  setHTMLElemAttribute('innerHTML', number_to_price(pricelist[row_number][2]), 'price_line', true);
  current_item = pricelist[row_number][0];
}

// convertToNumber puzzle
function toNumber(text) {
    var num = Number(text);
    if (isNaN(num))
        num = 0;
    return num;
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}

// Describe this function...
function item_quantity_changing(item_quantity_id, list_id, add_or_sub) {
  if (add_or_sub == 1) {
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', item_quantity_id, true)) + 1, item_quantity_id, true);
    total_items_in_basket = total_items_in_basket + 1;
  } else {
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', item_quantity_id, true)) - 1, item_quantity_id, true);
    total_items_in_basket = total_items_in_basket - 1;
  }
  setHTMLElemAttribute('innerHTML', total_items_in_basket, 'items_in_basket', true);
  if (toNumber(getHTMLElemAttribute('innerHTML', item_quantity_id, true)) == 0) {
    setHTMLElemStyle('display', 'none', list_id, true);
  }
  check_total_price();
}

// readCSV puzzle
function readCSV(text, delimit, from) {
    if (PzLib.isDataUrl(text)) {
        text = PzLib.extractDataUrlData(text);
    }

    return v3d.CSVParser.parse(text,
        {delimiter: delimit, skipinitialrows: from});
}

// loadFile puzzle
_pGlob.loadedFiles = {};

function loadFile(url, callback, caching) {

    const files = _pGlob.loadedFiles;

    if (!url || (typeof url != 'string')) {
        _pGlob.loadedFile = '';
        callback();
    } else if (caching && url in files) {
        _pGlob.loadedFile = files[url];
        callback();
    } else {
        const req = new XMLHttpRequest();

        req.onreadystatechange = function() {
            if (req.readyState == 4 && req.status == 200) {
                if (req.getResponseHeader('Content-Type').indexOf('application/json') > -1)
                    _pGlob.loadedFile = JSON.parse(req.responseText);
                else
                    _pGlob.loadedFile = req.responseText;

                if (caching)
                    files[url] = _pGlob.loadedFile;

                callback();
            }
        };
        req.open('GET', url, true);
        req.send();
    }
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        PzLib.bindListener(elem, eventType, callback);
    }
}

// replaceTexture puzzle
function replaceTexture(matName, texName, texUrlOrElem, doCb) {

    const textures = PzLib.getMaterialEditableTextures(matName, true).filter(function(elem) {
        return elem.name == texName;
    });

    if (!textures.length)
        return;

    const mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    if (texUrlOrElem instanceof Promise) {

        texUrlOrElem.then(function(response) {
           processImageUrl(response);
        }, function(error) {});

    } else if (typeof texUrlOrElem == 'string') {

        processImageUrl(texUrlOrElem);

    /**
     * NOTE: not checking for the PzLib.MediaHTML5 constructor, because otherwise this
     * puzzle would always provide the code that's not needed most of the time
     */
    } else if (texUrlOrElem instanceof Object && texUrlOrElem.source
            instanceof HTMLVideoElement) {

        processVideo(texUrlOrElem.source);

    } else if (texUrlOrElem instanceof HTMLCanvasElement) {

        processCanvas(texUrlOrElem);

    } else {

        return;

    }

    function processImageUrl(url) {

        const isHDR = (url.search(/\.hdr$/) > 0);
        const isComp = (url.search(/\.ktx2/) > 0);

        let isCompOld = false;
        let isVideoOld = false;
        textures.forEach(function(elem) {
            if (elem.isCompressedTexture)
                isCompOld = true;
            if (elem.isVideoTexture)
                isVideoOld = true;
        });

        let loader;

        if (!isHDR && !isComp && !isCompOld && !isVideoOld) {
            loader = new v3d.ImageLoader();
            loader.setCrossOrigin('Anonymous');
        } else if (isComp) {
            loader = appInstance.loader.ktx2Loader;
            loader.setCrossOrigin('Anonymous');
        } else if (isCompOld || isVideoOld) {
            loader = new v3d.TextureLoader();
            loader.setCrossOrigin('Anonymous');
        } else {
            loader = new v3d.FileLoader();
            loader.setResponseType('arraybuffer');
        }

        loader.load(url, function(loadedData) {

            textures.forEach(function(elem) {

                elem.dispose();

                if (!isHDR && !isComp && !isCompOld && !isVideoOld) {

                    elem.image = loadedData;

                } else if (isComp || isCompOld || isVideoOld) {

                    mats.forEach(function(mat) {
                        loadedData.flipY = false;
                        loadedData.name = texName;
                        PzLib.replaceMaterialEditableTexture(mat, elem, loadedData);
                        mat.needsUpdate = true;
                    });

                } else {

                    // parse loaded HDR buffer
                    var rgbeLoader = new v3d.RGBELoader();
                    var texData = rgbeLoader.parse(loadedData);

                    elem.image = {
                        data: texData.data,
                        width: texData.width,
                        height: texData.height
                    }

                    elem.magFilter = v3d.LinearFilter;
                    elem.minFilter = v3d.LinearFilter;
                    elem.generateMipmaps = false;
                    elem.isDataTexture = true;
                }

                // update world material if it is using this texture
                if (appInstance.scene !== null && appInstance.scene.worldMaterial !== null) {
                    var wMat = appInstance.scene.worldMaterial;
                    for (let texName in wMat.nodeTextures) {
                        if (wMat.nodeTextures[texName] == elem) {
                            appInstance.updateEnvironment(wMat);
                        }
                    }
                }
            });

            // exec once
            doCb();

        });
    }

    function processVideo(elem) {
        const videoTex = new v3d.VideoTexture(elem);
        videoTex.flipY = false;
        videoTex.name = texName;

        let videoAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            textures.forEach(function(tex) {
                PzLib.replaceMaterialEditableTexture(mat, tex, videoTex);
            });

            mat.needsUpdate = true;
            // HACK: to assign new encoding in nodes, workaround for https://crbug.com/1256340
            // HACK: preserve links to uniform arrays which got replaced in updateNodeGraph()
            if (mat.isMeshNodeMaterial) {
                const nodeRGBArrSave = mat.nodeRGBArr;
                const nodeValueSave = mat.nodeValue;
                mat.updateNodeGraph();
                mat.nodeRGBArr = nodeRGBArrSave;
                mat.nodeValue = nodeValueSave;
            }

            videoAssigned = true;
        });

        if (videoAssigned) {
            if (elem.readyState < 1) {
                PzLib.bindListener(elem, 'loadedmetadata', doCb);
            } else {
                doCb();
            }
        }

    }

    function processCanvas(elem) {
        const canvasTex = new v3d.CanvasTexture(elem);
        canvasTex.flipY = false;
        canvasTex.name = texName;

        let canvasAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            textures.forEach(function(tex) {
                PzLib.replaceMaterialEditableTexture(mat, tex, canvasTex);
            });

            mat.needsUpdate = true;
            canvasAssigned = true;
        });

        if (canvasAssigned) {

            if (PL) {
                PL.canvasTextures = PL.canvasTextures || {};
                PL.canvasTextures[canvasTex.image.id] = canvasTex;
            }

            doCb();
        }

    }
}

// setMaterialValue puzzle
function setMaterialValue(matName, valName, value) {

    var values = PzLib.getMaterialEditableValues(matName);
    if (values.indexOf(valName) < 0)
        return;

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var valIdx = mat.nodeValueMap[valName];
            mat.nodeValue[valIdx] = Number(value);
        } else
            mat[valName] = Number(value);

        if (appInstance.scene !== null) {
            if (mat === appInstance.scene.worldMaterial) {
                appInstance.updateEnvironment(mat);
            }
        }
    }
}

function placeOrderAdv() {
    return (function(url, items, attachments) {
        // placeOrderAdv puzzle
        function doPost(url, params) {
            const form = document.createElement('form');
            form.setAttribute('method', 'post');
            form.setAttribute('action', url);
            form.setAttribute('target', 'v3d_view');

            params.forEach(param => {
                const key = param[0];
                const value = param[1];
                const hiddenField = document.createElement('input');
                hiddenField.setAttribute('type', 'hidden');
                hiddenField.setAttribute('name', key);
                hiddenField.setAttribute('value', value);
                form.appendChild(hiddenField);
            });

            document.body.appendChild(form);
            window.open('', 'v3d_view');
            form.submit();
        }

        function base64EncodeUnicode(str) {
            return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
                function toSolidBytes(match, p1) {
                    return String.fromCharCode('0x' + p1);
            }));
        }

        function prepareAttachment(att, orderParams) {
            if (typeof att === 'string' && att.indexOf('data:') == 0)
                orderParams.push(['v3d_attachments[]', att]);
            else if (typeof att === 'string')
                orderParams.push(['v3d_attachments[]', 'data:text/plain;base64,' + base64EncodeUnicode(att)]);
        }

        items = Array.isArray(items) ? items : [items];
        items = items.filter(item => item);

        const orderParams = [
            ['v3d_items', JSON.stringify(items)]
        ];

        attachments = Array.isArray(attachments) ? attachments : [attachments];
        attachments = attachments.filter(att => att);

        let resolvePromises = false;

        for (let i = 0; i < attachments.length; i++) {
            if (attachments[i] instanceof Promise) {
                resolvePromises = true;
                break;
            }
        }

        if (resolvePromises) {
            Promise.all(attachments).then(attachmentsResolved => {
                attachmentsResolved.forEach(att => {
                    prepareAttachment(att, orderParams);
                });
                doPost(url, orderParams);
            });
        } else {
            attachments.forEach(att => {
                prepareAttachment(att, orderParams);
            });
            doPost(url, orderParams);
        }
    }).apply(null, arguments);
}

_pGlob.animMixerCallbacks = [];

var initAnimationMixer = function() {

    function onMixerFinished(e) {
        var cb = _pGlob.animMixerCallbacks;
        var found = [];
        for (var i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (var i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished)) {
            PzLib.bindListener(appInstance.mixer, 'finished', onMixerFinished);
        }
    };

}();

// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;
        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();
                if (loop && (loop != "AUTO"))
                    action.loop = v3d[loop];
                var scene = PzLib.getSceneByAction(action);
                var frameRate = PzLib.getSceneAnimFrameRate(scene);

                action.repetitions = Infinity;

                var timeScale = Math.abs(parseFloat(speed));
                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                var callbacks = _pGlob.animMixerCallbacks;
                var found = false;

                for (var j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            var callbacks = _pGlob.animMixerCallbacks;
            for (var j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            var scene = PzLib.getSceneByAction(action);
            var frameRate = PzLib.getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        case 'SET_SPEED':
            var timeScale = parseFloat(speed);
            action.timeScale = rev ? -timeScale : timeScale;
            break;
        }
    }

    for (var i = 0; i < animations.length; i++) {
        var animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}

// socialShareLink puzzle
function socialShareLink(media, title, text) {

    function fixedEncodeURIComponent(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
            return '%' + c.charCodeAt(0).toString(16);
        });
    }

    switch(media) {
    case 'TWITTER':
        return 'https://twitter.com/intent/tweet?url=' +
            fixedEncodeURIComponent(window.location.href) +
            '&text=' + fixedEncodeURIComponent(title);
    case 'FB':
        return 'http://www.facebook.com/sharer.php?u=' +
            fixedEncodeURIComponent(window.location.href);
    case 'REDDIT':
        return 'https://reddit.com/submit?url=' +
            fixedEncodeURIComponent(window.location.href) +
            '&title=' + fixedEncodeURIComponent(title);
    case 'LINKEDIN':
        return 'https://www.linkedin.com/shareArticle?mini=true&url=' +
            fixedEncodeURIComponent(window.location.href) +
             '&title=' + fixedEncodeURIComponent(title) +
             '&summary=' + fixedEncodeURIComponent(text);
    case 'VK':
        return 'http://vk.com/share.php?url=' +
            fixedEncodeURIComponent(window.location.href) +
            '&title=' + fixedEncodeURIComponent(title) +
            '&comment=' + fixedEncodeURIComponent(text);
    case 'WEIBO':
        return 'http://service.weibo.com/share/share.php?url=' +
            fixedEncodeURIComponent(window.location.href) +
            '&title=' + fixedEncodeURIComponent(title);
    }
}

// openWebPage puzzle
function openWebPage(url, mode) {

    if (appInstance && appInstance.controls) {
        appInstance.controls.forceMouseUp();
    }

    if (mode == "NEW") {
        window.open(url);
    } else if (mode == "NO_RELOAD") {
        history.pushState('verge3d state', 'verge3d page', url);
    } else {
        var target;
        switch (mode) {
            case "SAME":
                target = "_self";
                break;
            case "TOP":
                target = "_top";
                break;
            case "PARENT":
                target = "_parent";
                break;
        }

        window.open(url, target);

    }
}


loadFile('ar_pricelist.csv', function() {
  pricelist = readCSV(_pGlob.loadedFile, ',', 1);
  pricelist_read(1);
}, true);
setHTMLElemStyle('visibility', 'hidden', 'fullscreen-button', false);
recliner_unfolded = 0;
animated_parts = ['base', 'recliner_part_8', 'recliner_metal_part_1', 'recliner_metal_part_2', 'recliner_metal_part_3', 'recliner_part_2'];
reclainer_parts = ['recliner_part_1', 'recliner_part_2', 'recliner_part_3', 'recliner_part_4', 'recliner_part_5', 'recliner_part_6', 'recliner_part_7', 'recliner_part_8', 'recliner_part_9', 'recliner_part_10'];
current_item = 'Awesome Recliner AR-RD16';
total_items_in_basket = 0;
shopping_cart = [];

eventHTMLElem('click', 'item_quantity_plus_button_1', true, function(event) {
  item_quantity_changing('item_quantity_1', 'list_1', 1);
});

eventHTMLElem('click', 'item_quantity_minus_button_1', true, function(event) {
  item_quantity_changing('item_quantity_1', 'list_1', -1);
});

eventHTMLElem('click', 'black_leather_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_leather_black_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_leather_black_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_leather_black_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 0);
  pricelist_read(0);
});
eventHTMLElem('click', 'red_leather_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_leather_red_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_leather_red_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_leather_red_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 0);
  pricelist_read(1);
});
eventHTMLElem('click', 'white_leather_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_leather_white_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_leather_white_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_leather_white_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 0);
  pricelist_read(2);
});
eventHTMLElem('click', 'blue_velvet_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_velvet_blue_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_velvet_blue_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_velvet_blue_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 1);
  pricelist_read(3);
});
eventHTMLElem('click', 'green_velvet_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_velvet_green_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_velvet_green_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_velvet_green_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 1);
  pricelist_read(4);
});
eventHTMLElem('click', 'textile_lines_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_textile_lines_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_textile_lines_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_textile_lines_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 0.5);
  pricelist_read(5);
});
eventHTMLElem('click', 'textile_grid_button', true, function(event) {
  replaceTexture('recliner_material', 'BaseColor', './recliner_textile_grid_BaseColor.jpg', function() {});
  replaceTexture('recliner_material', 'OcclusionRoughnessMetallic', './recliner_textile_grid_OcclusionRoughnessMetallic.jpg', function() {});
  replaceTexture('recliner_material', 'Normal', './recliner_textile_grid_Normal.png', function() {});
  setMaterialValue('recliner_material', 'sheen', 0.5);
  pricelist_read(6);
});

eventHTMLElem('click', 'item_quantity_plus_button_2', true, function(event) {
  item_quantity_changing('item_quantity_2', 'list_2', 1);
});

eventHTMLElem('click', 'item_quantity_plus_button_3', true, function(event) {
  item_quantity_changing('item_quantity_3', 'list_3', 1);
});

eventHTMLElem('click', 'item_quantity_plus_button_4', true, function(event) {
  item_quantity_changing('item_quantity_4', 'list_4', 1);
});

eventHTMLElem('click', 'item_quantity_plus_button_5', true, function(event) {
  item_quantity_changing('item_quantity_5', 'list_5', 1);
});

eventHTMLElem('click', 'item_quantity_plus_button_6', true, function(event) {
  item_quantity_changing('item_quantity_6', 'list_6', 1);
});

eventHTMLElem('click', 'item_quantity_plus_button_7', true, function(event) {
  item_quantity_changing('item_quantity_7', 'list_7', 1);
});

eventHTMLElem('click', 'item_quantity_minus_button_2', true, function(event) {
  item_quantity_changing('item_quantity_2', 'list_2', -1);
});

eventHTMLElem('click', 'item_quantity_minus_button_3', true, function(event) {
  item_quantity_changing('item_quantity_3', 'list_3', -1);
});

eventHTMLElem('click', 'item_quantity_minus_button_4', true, function(event) {
  item_quantity_changing('item_quantity_4', 'list_4', -1);
});

eventHTMLElem('click', 'item_quantity_minus_button_5', true, function(event) {
  item_quantity_changing('item_quantity_5', 'list_5', -1);
});

eventHTMLElem('click', 'item_quantity_minus_button_6', true, function(event) {
  item_quantity_changing('item_quantity_6', 'list_6', -1);
});

eventHTMLElem('click', 'item_quantity_minus_button_7', true, function(event) {
  item_quantity_changing('item_quantity_7', 'list_7', -1);
});

eventHTMLElem('click', ['basket_button', 'items_in_basket'], true, function(event) {
  setHTMLElemStyle('display', 'block', 'shopping_cart', true);
});

eventHTMLElem('click', 'checkout_button', true, function(event) {
  if (total_items_in_basket != 0) {
    shopping_cart = [];
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_1', true)) != 0) {
      shopping_cart.push(({'sku': '107482', 'quantity': toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_1', true))}));
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_2', true)) != 0) {
      shopping_cart.push(({'sku': '107483', 'quantity': toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_2', true))}));
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_3', true)) != 0) {
      shopping_cart.push(({'sku': '107484', 'quantity': toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_3', true))}));
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_4', true)) != 0) {
      shopping_cart.push(({'sku': '107485', 'quantity': toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_4', true))}));
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_5', true)) != 0) {
      shopping_cart.push(({'sku': '107486', 'quantity': toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_5', true))}));
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_6', true)) != 0) {
      shopping_cart.push(({'sku': '107487', 'quantity': toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_6', true))}));
    }
    if (toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_7', true)) != 0) {
      shopping_cart.push(({'sku': '107488', 'quantity': toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_7', true))}));
    }
    placeOrderAdv('https://sandbox.soft8soft.com/order-form/', shopping_cart, []);}
});

eventHTMLElem('click', 'continue_shopping_button', true, function(event) {
  setHTMLElemStyle('display', 'none', 'shopping_cart', true);
});

eventHTMLElem('click', 'add_to_cart_button', true, function(event) {
  total_items_in_basket = total_items_in_basket + 1;
  if (current_item == 'Awesome Recliner AR-BL16') {
    setHTMLElemStyle('display', 'block', 'list_1', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_1', true)) + 1, 'item_quantity_1', true);
  } else if (current_item == 'Awesome Recliner AR-RD16') {
    setHTMLElemStyle('display', 'block', 'list_2', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_2', true)) + 1, 'item_quantity_2', true);
  } else if (current_item == 'Awesome Recliner AR-BT16') {
    setHTMLElemStyle('display', 'block', 'list_3', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_3', true)) + 1, 'item_quantity_3', true);
  } else if (current_item == 'Awesome Recliner AR-BU16') {
    setHTMLElemStyle('display', 'block', 'list_4', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_4', true)) + 1, 'item_quantity_4', true);
  } else if (current_item == 'Awesome Recliner AR-GR16') {
    setHTMLElemStyle('display', 'block', 'list_5', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_5', true)) + 1, 'item_quantity_5', true);
  } else if (current_item == 'Awesome Recliner AR-TL16') {
    setHTMLElemStyle('display', 'block', 'list_6', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_6', true)) + 1, 'item_quantity_6', true);
  } else if (current_item == 'Awesome Recliner AR-TG16') {
    setHTMLElemStyle('display', 'block', 'list_7', true);
    setHTMLElemAttribute('innerHTML', toNumber(getHTMLElemAttribute('innerHTML', 'item_quantity_7', true)) + 1, 'item_quantity_7', true);
  }
  setHTMLElemAttribute('innerHTML', total_items_in_basket, 'items_in_basket', true);
  check_total_price();
});

eventHTMLElem('click', 'change_position_button', true, function(event) {
  if (recliner_unfolded == 0) {
    setHTMLElemStyle('backgroundImage', 'url("images/fold.png")', 'change_position_button', true);

    operateAnimation('PLAY', animated_parts, 1, 75, 'AUTO', 1,
            function() {
      recliner_unfolded = 1;
    }, false);

        } else if (recliner_unfolded == 1) {
    setHTMLElemStyle('backgroundImage', 'url("images/unfold.png")', 'change_position_button', true);

    operateAnimation('PLAY', animated_parts, 1, 75, 'AUTO', 1,
            function() {
      recliner_unfolded = 0;
    }, true);

        }
});
eventHTMLElem('click', 'facebook_button', true, function(event) {
  openWebPage(socialShareLink('FB', 'Awesome Recliner', 'This stylish and soft recliner has well padded arms and back cushions. It has been designed and manufactured with the highest standards in mind offering an exceptional strength, durability and paramount comfort.'), 'NEW');
});
eventHTMLElem('click', 'twitter_button', true, function(event) {
  openWebPage(socialShareLink('TWITTER', 'Awesome Recliner', 'This stylish and soft recliner has well padded arms and back cushions. It has been designed and manufactured with the highest standards in mind offering an exceptional strength, durability and paramount comfort.'), 'NEW');
});
eventHTMLElem('click', 'linkedin_button', true, function(event) {
  openWebPage(socialShareLink('LINKEDIN', 'Awesome Recliner', 'This stylish and soft recliner has well padded arms and back cushions. It has been designed and manufactured with the highest standards in mind offering an exceptional strength, durability and paramount comfort.'), 'NEW');
});
eventHTMLElem('click', 'google_button', true, function(event) {
  openWebPage(socialShareLink('GPLUS', 'Awesome Recliner', 'This stylish and soft recliner has well padded arms and back cushions. It has been designed and manufactured with the highest standards in mind offering an exceptional strength, durability and paramount comfort.'), 'NEW');
});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
